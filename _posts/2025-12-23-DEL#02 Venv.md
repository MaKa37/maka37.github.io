---
title: "DEL#02: Type Hinting & MyPy"
description: "데이터 엔지니어 학습: 타입 힌팅과 정적 분석"
layout: single
categories: [DataEngineer, Learning]
author_profile: true

toc: true
toc_icon: "heart"
toc_label: "Contents"
toc_sticky: True
---

***

# 데이터 엔지니어 학습: 타입 힌팅과 정적 분석
파이썬은 동적 타이핑 언어이지만 데이터 엔지니어링 환경에서는 명시적인 타입 정의가 필수입니다.
수천 줄의 파이프라인 코드에서 데이터의 흐름을 안전하게 관리하는 방법을 학습합니다.

## 학습 개요
1. 타입 힌팅(Type Hinting)의 필요성
    - 런타임 에러 사전 방지: 코드를 실행하기 전에 `int`가 들어와야 할 곳에 `None`이나 `String`이 들어오는 실수를 잡아낼 수 있다.
    - IDE 지원 극대화: 타입이 명시되면 VS Code나 PyCharm에서 자동 완성 기능을 100% 활용할 수 있어 개발 속도가 비약적으로 향상됩니다.
    - 살아있는 문서(Living Documentation): 함수의 입력과 출력을 타입으로 명시함으로써 별도의 주석 없이 코드의 의도를 파악할 수 있습니다.

2. `typing` 모듈의 핵심 요소
    - 기본 타입: `int`, `str`, `float`, `bool`
    - 컬렉션 타입: `List`, `Dict`, `Tuple`, `Set`(Python 3.9 이상은 소문자 `list`, `dict` 사용 권장)
    - 고급 타입:
        + `Optional[T]`: 값이 `T`이거나 `None` 일 수 있음을 명시(매우 중요)
        + `Union[T1, T2]`: 여러 타입 중 하나일 수 있음을 명시.
        + `Any`: 모든 타입을 허용(가급적 사용 자제).
        + `Callable`: 함수 자체를 인자로 받을 때 사용.

3. MyPy: 정적 타입 검사기(Static Type Checker)
    - 역할: 데이터 타입의 불일치로 인해 발생될 수 있는 잠재적 오류를 런타임 이전에 탐지하여 파이프라인 안전성을 보장합니다.
        + Runtime Overhead Zero: MyPy는 검사만 할 뿐 실제 실행 시 성능에 전혀 영향을 주지 않습니다.
        + Type Narrowing: 데이터가 `None`일 가능성(Optional)을 강제로 체크하게 하여 `AttributeError`를 방지합니다.
        + CI/CD 연동: 깃허브에 코드를 올릴 때(GitHub Actions) MyPy 검사를 통과해야만 배포가 되도록 설정하여 코드 품질을 강제합니다.
    - 데이터 스키마 관리 및 검증: 데이터 소스 변경 또는 상위(Upstream) 시스템의 데이터 엔지니어는 스키마 변동 시 시스템 전체를 수정해야됩니다.
        + Data Class Mapping: `TypedDict`나 `NamedTuple`을 사용하여 데이터 레코드의 형식을 명확히 규정합니다.
        + Refactoring Guard: 컬렉션 내의 필드 이름을 변경할 때 MyPy가 고쳐야 할 모든 곳을 정확히 찾아줍니다.
    - 팀 협업 및 유지보수 향상
        + Self-Documenting Code: 별도의 문서 없이 코드 자체로 입력과 출력을 설명합니다.
        + IDE Support: VS Code나 PyCharm에서 자동 완성과 에러 강조 표시가 훨씬 정교해집니다.
    - 데이터 엔지니어링 스택 내 MyPy 활용
        + Pydantic 연동: 데이터 유효성 검사 라이브러리인 Pydantic과 함께 사용하여 런타임과 정적 타입 검사를 동시에 해결합니다.
        + Airflow DAGs: Operator 간의 파라미터 전달 시 잘못된 인자가 넘어가는 실수를 방지합니다.
        + PySpark Logic: UDF(User Defined Functions)의 입력과 출력 타입을 명시하여 스파크 잡의 신뢰도를 높입니다.
        + API Integration: 외부 데이터 소스로부터 받는 JSON 응답 구조를 타입으로 정의하여 파싱 에러를 예방합니다.

## 단계별 실습 워크플로우
1. 기본 함수 타입 정의
```python
def process_data(data: list[int]) -> float:
    return sum(data) / len(data)
```

### 2. MyPy

#### Mypy 설치
1. 설치 및 초기화: `pip install mypy` 후 프로젝트 루트에 `mypy.ini` 설정을 추가하세요.
    - python3 -m pip install mypy
    - mypy program.py
2. 점진적 타이핑
    - `poetry add --group dev mypy`
    - `poetry run mypy your_script.py` 명령어로 타입 오류 확인.

```python
# data_processor.py
from typing import List, Dict, Optional

def calculate_avg_sales(data: List[Dict[str, int]]) -> float:
total = sum(d["sales"] for d in data)
return total / len(data)

# 시나리오: 잘못된 데이터 스키마가 들어온 경우
raw_data = [{"sales": "100"}, {"sales": "250"}]

print(calculate_avg_sales(raw_data))
```

3. 데이터 엔지니어링 실무 패턴 적용
    - 외부 API 호출 결과나 DB 쿼리 결과에 대해 TypeDict나 NameTuple을 사용하여 구조 정의.
    - 복잡한 중첩 딕셔너리 구조를 명확하게 타입화.

## 데이터 엔지니어의 체크포인트(Best Practices)
 - Optional의 생활화: 데이터베이스에서 데이터를 읽어올 때 null 값이 포함될 수 있다면 반드시 Optional 사용 권장
 - 최대한 구체적으로: `list` 보다는 `list[str]` 와 같이 내부 요소의 타입까지 명시하는 것이 좋다.
 - 타입 별칭(Type Alias): 복잡한 타입은 `DataRow = dict[str, Union[int, str]]`와 같이 별칭을 주어 재사용 권장
 - Gradual Typing: 기존의 방대한 코드에 한꺼번에 타입 적용하기 어렵다면, 중요한 함수부터 차례대로 적용해나가는 전략 권장

 ## 추천 연습 과제
- 과제 1: 사용자 정보(이름, 나이, 이메일)를 담은 리스트를 받아 나이의 평균을 구하는 함수를 작성하고, mypy 검사를 통과시켜 보세요.
- 과제 2: Optional 타입을 사용하지 않았을 때 None 값이 들어오면 발생하는 에러를 mypy가 어떻게 잡아내는지 확인해 보세요.
- 과제 3: from typing import Annotated를 활용해 단위(예: meters, seconds) 정보를 포함하는 커스텀 타입을 만들어 보세요.
